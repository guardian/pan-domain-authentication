package com.gu.pandomainauth

import cats.*
import cats.syntax.all.*
import com.gu.pandomainauth.ApiResponse.DisallowApiAccess
import com.gu.pandomainauth.CookieAction.PersistAuth
import com.gu.pandomainauth.CookieChanges.NameAndDomain
import com.gu.pandomainauth.model.*
import com.gu.pandomainauth.oauth.OAuthUrl

import java.math.BigInteger
import java.net.URI
import java.security.SecureRandom



case class CookieChanges(
  setSessionCookies: Map[NameAndDomain, String] = Map.empty,
  wipeCookies: Set[NameAndDomain] = Set.empty
)

object CookieChanges {
  val NoChanges = CookieChanges()

  /**
   * @param domain if populated, the domain the cookie should be dropped on (eg gutools.co.uk). If empty, leave the
   *               cookie domain unspecified when creating the cookie - browsers interpret this as meaning that
   *               the cookie domain should be the exact domain of the site storing the cookie (eg composer.gutools.co.uk)
   *               ...this is appropriate for temporary OAuth-callback-related cookies.
   */
  case class NameAndDomain(name: String, domain: Option[String])
}

sealed trait CookieAction

object CookieAction {
  case object Logout extends CookieAction
  case class PersistAuth(authenticatedUser: AuthenticatedUser, wipeTemporaryCookiesUsedForOAuth: Boolean = false) extends CookieAction
  case class PrepareForOAuth(antiForgeryToken: String, wipeAuthCookie: Boolean = false) extends CookieAction
}

/**
 * Keep ResponseModification framework-adapter-facing - the simplest possible thing for the framework-adapter to process
 *
 * This means it can no longer be used by the Plan class - which we would like to test using higher-level concepts
 * like CookieAction.
 */
case class ResponseModification[C](
  cookies: Option[C] = None,
  responseHeaders: Map[String, String] = Map.empty
) {
  def mapCookies[C2](f: C => C2): ResponseModification[C2] = copy(cookies.map(f))
}

object ResponseModification {
  def apply[C](c: C): ResponseModification[C] = ResponseModification(cookies = Some(c))
}

/**
 * A Panda-specific response to an HTTP request
 *
 * @param typ dictates the nature of the response - allowing access, or withholding access (redirecting, bad-request, etc)
 * @param responseModification any modifications that should be made to the response, even if that response is not
 *                             generated by Panda (ie a _normal_ page response for an authorised user)
 * @tparam T
 */
case class Plan[T](typ: T, responseModification: ResponseModification[CookieAction] = ResponseModification())

object Plan {
  def apply[T](typ: T, cookieAction: CookieAction): Plan[T] =
    Plan(typ, ResponseModification(cookies = Some(cookieAction)))
}

trait AuthedEndpointResponse
sealed trait PageResponse extends AuthedEndpointResponse
sealed trait WithholdAccess
sealed trait OAuthCallbackResponse extends PageResponse

case class AllowAccess(user: User) extends PageResponse with ApiResponse

object PageResponse {
  case class NotAuthorized(user: AuthenticatedUser) extends OAuthCallbackResponse with WithholdAccess
  case class Redirect(uri: URI) extends OAuthCallbackResponse with WithholdAccess
  case object BadRequest extends OAuthCallbackResponse
}

sealed trait ApiResponse extends AuthedEndpointResponse

object ApiResponse {
  case class HttpStatusCode(code: Int, message: String)

  trait DisallowApiAccess extends ApiResponse with WithholdAccess {
    val statusCode: HttpStatusCode
  }
  
  case object NotAuthorized extends DisallowApiAccess {
    val statusCode: HttpStatusCode = HttpStatusCode(403, "User is not authorized to use this tool")
  }

  case object NoAuthentication extends DisallowApiAccess {
    val statusCode: HttpStatusCode = HttpStatusCode(401, "Missing or expired auth cookie, or cookie with an integrity failure") // or 419, if they are expired & not acceptable?
  }
}

case class AuthPersistenceStatus(
  effectiveAuthStatus: AuthenticationStatus,
  systemsAuthorisationsCurrentlyPersistedWithUser: Set[String]
) {
  val hasUnpersistedSystemAuthorisations: Boolean = effectiveAuthStatus match {
    case acceptable: AcceptableAuthForApiRequests => acceptable.authedUser.isAuthorisedInMoreThan(systemsAuthorisationsCurrentlyPersistedWithUser)
    case _ => false
  }
}

/**
 * Authentication status needs to be handled differently depending on whether this is a full-page request,
 * or an API request:
 *
 * - Page request: can be redirected to an OAuth flow, so will immediately do so if credentials need refreshing - we
 * *do not* need to tolerate expired credentials for a grace period
 * - API request: can not redirect the whole page to an OAuth flow, only return a header recommending that the user
 * refresh the page - and if the user can not immediately do so, should tolerate older credentials for a grace period
 *
 * @tparam PandaResponseType
 */
trait AuthStatusHandler[PandaResponseType] {
  def planForAuthStatus(authPersistenceStatus: AuthPersistenceStatus): Plan[PandaResponseType]
}

object PageRequestHandlingStrategy {
  /**
   * A cookie key that stores the target URL that was being accessed when redirected for authentication
   */
  val LOGIN_ORIGIN_KEY: CookieChanges.NameAndDomain = CookieChanges.NameAndDomain("panda-loginOriginUrl", None)
  /*
   * Cookie key containing an anti-forgery token; helps to validate that the oauth callback arrived in response to the correct oauth request
   * Should only the main auth cookie be on the shared domain, while temp OAuth cookies be on the app-specific domain, to avoid clashes?
   */
  val ANTI_FORGERY_KEY: CookieChanges.NameAndDomain = CookieChanges.NameAndDomain("panda-antiForgeryToken", None)
  /*
   * Cookie that will make panda behave as if the cookie has expired.
   * NOTE: This cookie is for debugging only! It should _not_ be set by any application code to expire the cookie!! Use the `processLogout` action instead!!
   */
  val FORCE_EXPIRY_KEY: CookieChanges.NameAndDomain = CookieChanges.NameAndDomain("panda-forceExpiry", None)

  val TemporaryCookiesUsedForOAuth: Set[CookieChanges.NameAndDomain] = Set(LOGIN_ORIGIN_KEY, ANTI_FORGERY_KEY, FORCE_EXPIRY_KEY)
}

class PageRequestHandlingStrategy[F[_]: Monad](oAuthUrl: OAuthUrl)(
  implicit authStatusFromRequest: AuthStatusFromRequest
) extends AuthStatusHandler[PageResponse] {

  import PageResponse.*
  val F: Monad[F] = Monad[F]
  
  private val random = new SecureRandom()

  private def redirectForAuth(loginHintEmail: Option[String] = None, wipeAuthCookie: Boolean = false): Plan[PageResponse] = {
    val antiForgeryToken: String = new BigInteger(130, random).toString(32)
    Plan(
      PageResponse.Redirect(oAuthUrl.uriOfOAuthProvider(antiForgeryToken, loginHintEmail)),
      CookieAction.PrepareForOAuth(antiForgeryToken, wipeAuthCookie)
    )
  }

  override def planForAuthStatus(authPersistenceStatus: AuthPersistenceStatus): Plan[PageResponse] =
    authPersistenceStatus.effectiveAuthStatus match {
      case NotAuthenticated => redirectForAuth()
      case InvalidCookie(_) => redirectForAuth(wipeAuthCookie = true)
      case stale: StaleUserAuthentication => redirectForAuth(loginHintEmail = Some(stale.authedUser.user.email))
      case com.gu.pandomainauth.model.NotAuthorized(authedUser) => Plan(NotAuthorized(authedUser))
      case Authenticated(authedUser) => Plan(AllowAccess(authedUser.user),
        ResponseModification(cookies = Option.when(authPersistenceStatus.hasUnpersistedSystemAuthorisations)(PersistAuth(authedUser)))
      )
    }
}

object ApiRequestHandlingStrategy extends AuthStatusHandler[ApiResponse] {
  import ApiResponse.*

  val suggestCredentialRefresh: Map[Boolean, Map[String, String]] = Set(false, true).map(bool => bool -> Map(
    "X-Panda-Should-Refresh-Credentials" -> bool.toString
  )).toMap

  def planForAuthStatus(authPersistenceStatus: AuthPersistenceStatus): Plan[ApiResponse] = authPersistenceStatus.effectiveAuthStatus match {
    case NotAuthenticated | InvalidCookie(_) | Expired(_) => Plan(NoAuthentication)
    case com.gu.pandomainauth.model.NotAuthorized(_) => Plan(NotAuthorized)
    case acceptable: AcceptableAuthForApiRequests =>
      Plan(AllowAccess(acceptable.authedUser.user), ResponseModification(responseHeaders = suggestCredentialRefresh(acceptable.shouldBeRefreshed)))
  }
}
