package com.gu.pandomainauth

import cats._
import cats.syntax.all._
import com.gu.pandomainauth.ApiResponse.{DisallowApiAccess, HttpStatusCode}
import com.gu.pandomainauth.PageRequestHandlingStrategy.{ANTI_FORGERY_KEY, LOGIN_ORIGIN_KEY, TemporaryCookiesUsedForOAuth}
import com.gu.pandomainauth.ResponseModification.NoResponseModification
import com.gu.pandomainauth.model.*
import com.gu.pandomainauth.oauth.OAuthValidator
import com.gu.pandomainauth.service.CookieUtils.generateCookieData
import com.gu.pandomainauth.service.CryptoConf.Signing

import java.math.BigInteger
import java.net.{URI, URLDecoder}
import java.nio.charset.StandardCharsets.UTF_8
import java.security.SecureRandom
import scala.concurrent.{ExecutionContext, Future}

case class CookieChanges(
  domain: String,
  setSessionCookies: Map[String, String] = Map.empty,
  wipeCookies: Set[String] = Set.empty
)

case class ResponseModification(responseHeaders: Map[String, String] = Map.empty, cookieChanges: Option[CookieChanges] = None)

object ResponseModification {
  val NoResponseModification: ResponseModification = ResponseModification()
}

/**
 * A Panda-specific response to an HTTP request
 *
 * @param typ
 * @param responseModification any modifications that should be made to the response, even if that response is not
 *                             generated by Panda (ie a _normal_ page response for an authorised user)
 * @tparam T
 */
case class Plan[+T](typ: T, responseModification: ResponseModification = NoResponseModification)

sealed trait PageResponse
sealed trait OAuthCallbackResponse

object PageResponse {
  case class AllowAccess(user: User) extends PageResponse
  case class NotAuthorized(user: User) extends PageResponse with OAuthCallbackResponse
  case class Redirect(uri: URI) extends PageResponse with OAuthCallbackResponse
}

sealed trait ApiResponse

object ApiResponse {
  case class HttpStatusCode(code: Int, message: String)

  trait DisallowApiAccess extends ApiResponse {
    val statusCode: HttpStatusCode
  }

  case class AllowAccess(user: User) extends ApiResponse

  case object NotAuthorized extends DisallowApiAccess {
    val statusCode: HttpStatusCode = HttpStatusCode(403, "User is not authorized to use this tool")
  }

  case object NoAuthentication extends DisallowApiAccess {
    val statusCode: HttpStatusCode = HttpStatusCode(401, "Missing or expired auth cookie, or cookie with an integrity failure") // or 419, if they are expired & not acceptable?
  }
}

/**
 * Authentication status needs to be handled differently depending on whether this is a full-page request,
 * or an API request:
 *
 * - Page request: can be redirected to an OAuth flow, so will immediately do so if credentials need refreshing - we
 * *do not* need to tolerate expired credentials for a grace period
 * - API request: can not redirect the whole page to an OAuth flow, only return a header recommending that the user
 * refresh the page - and if the user can not immediately do so, should tolerate older credentials for a grace period
 *
 * @tparam PandaResponseType
 */
trait AuthStatusHandler[PandaResponseType] {
  def planForAuthStatus(authStatus: AuthenticationStatus): Plan[PandaResponseType]
}

object PageRequestHandlingStrategy {
  /**
   * A cookie key that stores the target URL that was being accessed when redirected for authentication
   */
  val LOGIN_ORIGIN_KEY = "panda-loginOriginUrl"
  /*
   * Cookie key containing an anti-forgery token; helps to validate that the oauth callback arrived in response to the correct oauth request
   */
  val ANTI_FORGERY_KEY = "panda-antiForgeryToken"
  /*
   * Cookie that will make panda behave as if the cookie has expired.
   * NOTE: This cookie is for debugging only! It should _not_ be set by any application code to expire the cookie!! Use the `processLogout` action instead!!
   */
  val FORCE_EXPIRY_KEY = "panda-forceExpiry"

  val TemporaryCookiesUsedForOAuth: Set[String] = Set(LOGIN_ORIGIN_KEY, ANTI_FORGERY_KEY, FORCE_EXPIRY_KEY)
}

class PageRequestHandlingStrategy[F[_]: Monad](
  system: String,
  cookieResponses: CookieResponses,
  oAuthValidator: OAuthValidator[F],
  oAuthUrl: OAuthUrl
)(implicit
  authStatusFromRequest: AuthStatusFromRequest
) extends AuthStatusHandler[PageResponse] {
  require(authStatusFromRequest.system == system)
  require(authStatusFromRequest.cookieSettings == cookieResponses.cookieSettings)
  
  import PageResponse.*
  val F: Monad[F] = Monad[F]
  
  private val random = new SecureRandom()

  private def redirectForAuth(loginHintEmail: Option[String] = None, wipeAuthCookie: Boolean = false): Plan[PageResponse] = {
    val antiForgeryToken: String = new BigInteger(130, random).toString(32)
    Plan(PageResponse.Redirect(oAuthUrl.redirectToOAuthProvider(antiForgeryToken, loginHintEmail)),
      cookieResponses.responseForRedirectForAuth(antiForgeryToken, wipeAuthCookie)
    )
  }

  def planForAuthStatus(authStatus: AuthenticationStatus): Plan[PageResponse] = authStatus match {
    case NotAuthenticated => redirectForAuth()
    case InvalidCookie(_) => redirectForAuth(wipeAuthCookie = true)
    case stale: StaleUserAuthentication => redirectForAuth(loginHintEmail = Some(stale.authedUser.user.email))
    case com.gu.pandomainauth.model.NotAuthorized(authedUser) => Plan(NotAuthorized(authedUser.user))
    case Authenticated(authedUser) => Plan(AllowAccess(authedUser.user), cookieResponses.updateCookieToAddSystemIfNecessary(authedUser))
  }
}

object ApiRequestHandlingStrategy extends AuthStatusHandler[ApiResponse] {
  import ApiResponse.*

  val suggestCredentialRefresh: Map[Boolean, ResponseModification] = Set(false, true).map(bool => bool -> ResponseModification(responseHeaders = Map(
    "X-Panda-Should-Refresh-Credentials" -> bool.toString
  ))).toMap

  def planForAuthStatus(authStatus: AuthenticationStatus): Plan[ApiResponse] = authStatus match {
    case NotAuthenticated | InvalidCookie(_) | Expired(_) => Plan(NoAuthentication)
    case com.gu.pandomainauth.model.NotAuthorized(_) => Plan(NotAuthorized)
    case acceptable: AcceptableAuthForApiRequests => Plan(AllowAccess(acceptable.authedUser.user), suggestCredentialRefresh(acceptable.shouldBeRefreshed))
  }
}
