package com.gu.pandomainauth

import com.gu.pandomainauth.ApiResponse.{DisallowApiAccess, HttpStatusCode}
import com.gu.pandomainauth.PageRequestHandlingStrategy.{ANTI_FORGERY_KEY, LOGIN_ORIGIN_KEY, TemporaryCookiesUsedForOAuth}
import com.gu.pandomainauth.ResponseModification.NoResponseModification
import com.gu.pandomainauth.model.*
import com.gu.pandomainauth.oauth.OAuthValidator
import com.gu.pandomainauth.service.CookieUtils.generateCookieData
import com.gu.pandomainauth.service.CryptoConf.Signing

import java.math.BigInteger
import java.net.{URI, URLDecoder}
import java.nio.charset.StandardCharsets.UTF_8
import java.security.SecureRandom
import scala.concurrent.{ExecutionContext, Future}

case class CookieChanges(
  domain: String,
  setSessionCookies: Map[String, String] = Map.empty,
  wipeCookies: Set[String] = Set.empty
)

case class ResponseModification(responseHeaders: Map[String, String] = Map.empty, cookieChanges: Option[CookieChanges] = None)

object ResponseModification {
  val NoResponseModification: ResponseModification = ResponseModification()
}

/**
 * A Panda-specific response to an HTTP request
 *
 * @param typ
 * @param responseModification any modifications that should be made to the response, even if that response is not
 *                             generated by Panda (ie a _normal_ page response for an authorised user)
 * @tparam T
 */
case class Plan[+T](typ: T, responseModification: ResponseModification = NoResponseModification)

sealed trait PageResponse
sealed trait OAuthCallbackResponse

object PageResponse {
  case class AllowAccess(user: User) extends PageResponse
  case class NotAuthorized(user: User) extends PageResponse with OAuthCallbackResponse
  case class Redirect(uri: URI) extends PageResponse with OAuthCallbackResponse
}

sealed trait ApiResponse

object ApiResponse {
  case class HttpStatusCode(code: Int, message: String)

  trait DisallowApiAccess extends ApiResponse {
    val statusCode: HttpStatusCode
  }

  case class AllowAccess(user: User) extends ApiResponse

  case object NotAuthorized extends DisallowApiAccess {
    val statusCode: HttpStatusCode = HttpStatusCode(403, "User is not authorized to use this tool")
  }

  case object NoAuthentication extends DisallowApiAccess {
    val statusCode: HttpStatusCode = HttpStatusCode(401, "Missing or expired auth cookie, or cookie with an integrity failure") // or 419, if they are expired & not acceptable?
  }
}

/**
 * Authentication status needs to be handled differently depending on whether this is a full-page request,
 * or an API request:
 *
 * - Page request: can be redirected to an OAuth flow, so will immediately do so if credentials need refreshing - we
 * *do not* need to tolerate expired credentials for a grace period
 * - API request: can not redirect the whole page to an OAuth flow, only return a header recommending that the user
 * refresh the page - and if the user can not immediately do so, should tolerate older credentials for a grace period
 *
 * @tparam PandaResponseType
 */
trait AuthStatusHandler[PandaResponseType] {
  def planForAuthStatus(authStatus: AuthenticationStatus): Plan[PandaResponseType]
}

object PageRequestHandlingStrategy {
  /**
   * A cookie key that stores the target URL that was being accessed when redirected for authentication
   */
  val LOGIN_ORIGIN_KEY = "panda-loginOriginUrl"
  /*
   * Cookie key containing an anti-forgery token; helps to validate that the oauth callback arrived in response to the correct oauth request
   */
  val ANTI_FORGERY_KEY = "panda-antiForgeryToken"
  /*
   * Cookie that will make panda behave as if the cookie has expired.
   * NOTE: This cookie is for debugging only! It should _not_ be set by any application code to expire the cookie!! Use the `processLogout` action instead!!
   */
  val FORCE_EXPIRY_KEY = "panda-forceExpiry"

  val TemporaryCookiesUsedForOAuth: Set[String] = Set(LOGIN_ORIGIN_KEY, ANTI_FORGERY_KEY, FORCE_EXPIRY_KEY)
}

class PageRequestHandlingStrategy(
  system: String,
  domain: String,
  cookieSettings: CookieSettings,
  oAuthValidator: OAuthValidator,
  oAuthUrl: OAuthUrl,
  signing: () => Signing
)(implicit
  authStatusFromRequest: AuthStatusFromRequest
) extends AuthStatusHandler[PageResponse] {
  require(authStatusFromRequest.system == system)
  require(authStatusFromRequest.cookieSettings == cookieSettings)
  
  import PageResponse.*

  private def updateCookieToAddSystemIfNecessary(authedUser: AuthenticatedUser): ResponseModification =
    authedUser.requiringAdditional(system).fold(NoResponseModification) { updatedUser => cookieResponseFor(updatedUser) }

  private def cookieResponseFor(user: AuthenticatedUser, wipeTemporaryCookiesUsedForOAuth: Boolean = false) =
    ResponseModification(cookieChanges = Some(CookieChanges(
      domain,
      setSessionCookies = Map(cookieSettings.cookieName -> generateCookieData(user, signing())),
      wipeCookies = if (wipeTemporaryCookiesUsedForOAuth) TemporaryCookiesUsedForOAuth else Set.empty
    )))

  private val random = new SecureRandom()

  private def redirectForAuth(loginHintEmail: Option[String] = None, wipeAuthCookie: Boolean = false): Plan[PageResponse] = {
    val antiForgeryToken: String = new BigInteger(130, random).toString(32)

    Plan(PageResponse.Redirect(oAuthUrl.redirectToOAuthProvider(antiForgeryToken, loginHintEmail)),
      ResponseModification(cookieChanges = Some(CookieChanges(
        domain, // ?? Should only the main auth cookie be on the shared domain, while temp OAuth cookies be on the app-specific domain, to avoid clashes?
        setSessionCookies = Map(ANTI_FORGERY_KEY -> antiForgeryToken),
        wipeCookies = if (wipeAuthCookie) Set(cookieSettings.cookieName) else Set.empty
      )))
    )
  }

  val processLogout: ResponseModification = ResponseModification(
    cookieChanges = Some(CookieChanges(domain, wipeCookies = Set(cookieSettings.cookieName)))
  )
  
  
  def processOAuthCallback(request: PageRequest)(implicit ec: ExecutionContext): Future[Plan[OAuthCallbackResponse]] = {
    def decodeCookie(name: String): Option[String] =
      request.cookies.get(name).map(value => URLDecoder.decode(value, UTF_8))

    (for {
      expectedAntiForgeryToken <- decodeCookie(ANTI_FORGERY_KEY)
      antiForgeryTokenFromQueryParams <- request.queryParams.get("state") if antiForgeryTokenFromQueryParams == expectedAntiForgeryToken
      returnUrl <- decodeCookie(LOGIN_ORIGIN_KEY)
      code <- request.queryParams.get("code")
      } yield oAuthValidator.validate(code).map(newAuth => planFor(newAuth, request.authenticationStatus(), returnUrl))
    ) getOrElse Future.successful(Plan(???, ???)) // Future.successful(BadRequest("Missing cookies, bad anti-forgery, etc"))
  }

  private def planFor(newlyClaimedAuth: AuthenticatedUser, priorAuth: AuthenticationStatus, returnUrl: String) = {
    val authedSystemsFromPriorAuth: Set[String] = (priorAuth match {
      case Authenticated(authedUser) => Some(authedUser)
      case GracePeriod(authedUser) => Some(authedUser)
      case _ => None
    }).filter(_.user.email == newlyClaimedAuth.user.email).toSet.flatMap[String](_.authenticatedIn)
    val authedUserData = newlyClaimedAuth.copy(
      authenticatingSystem = system,
      authenticatedIn = authedSystemsFromPriorAuth + system,
      multiFactor = ??? // checkMultifactor(claimedAuth)
    )

    if (???) { // validateUser(authedUserData)
      Plan(PageResponse.Redirect(URI.create(returnUrl)), cookieResponseFor(authedUserData, wipeTemporaryCookiesUsedForOAuth = true))
    } else Plan(PageResponse.NotAuthorized(newlyClaimedAuth.user))
  }

  def planForAuthStatus(authStatus: AuthenticationStatus): Plan[PageResponse] = authStatus match {
    case NotAuthenticated => redirectForAuth()
    case InvalidCookie(_) => redirectForAuth(wipeAuthCookie = true)
    case stale: StaleUserAuthentication => redirectForAuth(loginHintEmail = Some(stale.authedUser.user.email))
    case com.gu.pandomainauth.model.NotAuthorized(authedUser) => Plan(NotAuthorized(authedUser.user))
    case Authenticated(authedUser) => Plan(AllowAccess(authedUser.user), updateCookieToAddSystemIfNecessary(authedUser))
  }
}

object ApiRequestHandlingStrategy extends AuthStatusHandler[ApiResponse] {
  import ApiResponse.*

  val suggestCredentialRefresh: Map[Boolean, ResponseModification] = Set(false, true).map(bool => bool -> ResponseModification(responseHeaders = Map(
    "X-Panda-Should-Refresh-Credentials" -> bool.toString
  ))).toMap

  def planForAuthStatus(authStatus: AuthenticationStatus): Plan[ApiResponse] = authStatus match {
    case NotAuthenticated | InvalidCookie(_) | Expired(_) => Plan(NoAuthentication)
    case com.gu.pandomainauth.model.NotAuthorized(_) => Plan(NotAuthorized)
    case acceptable: AcceptableAuthForApiRequests => Plan(AllowAccess(acceptable.authedUser.user), suggestCredentialRefresh(acceptable.shouldBeRefreshed))
  }
}
